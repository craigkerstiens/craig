<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Rails | Craig Kerstiens]]></title>
  <link href="http://www.craigkerstiens.com/categories/rails/atom.xml" rel="self"/>
  <link href="http://www.craigkerstiens.com/"/>
  <updated>2015-07-21T09:12:15-07:00</updated>
  <id>http://www.craigkerstiens.com/</id>
  <author>
    <name><![CDATA[Craig Kerstiens]]></name>
    <email><![CDATA[craig.kerstiens@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Simple database read scaling without sharding in rails]]></title>
    <link href="http://www.craigkerstiens.com/2013/03/06/simple-read-scaling-rails/"/>
    <updated>2013-03-06T00:00:00-08:00</updated>
    <id>http://www.craigkerstiens.com/2013/03/06/simple-read-scaling-rails</id>
    <content type="html"><![CDATA[<p>In an earlier post I provided a high level <a href="http://www.craigkerstiens.com/2012/11/30/sharding-your-database/">overview of sharding</a>. Sharding while a very solid approach to scaling capacity versus simply only relying on vertical scaling can also be a time intensive one. Additionally in some cases certain sites may only need extra capacity for a short lived period of time. Fortunately theres a nice middle ground alternative for scaling capacity that works well in quite a few cases. It even has a benefit that can potentially in place of sharding.</p>

<p>This method results in scaling your reads to replica databases, you can do this on Heroku by taking advantage of followers. A follower is a read only database on Heroku Postgres that receives asynchronous updates of your data usually only lagging a very few commits behind. This means you can write all of your data to the leader (main) database, and then read from another.</p>

<p><em>While you can arbitrarily do this there&rsquo;s some major benefits to doing it based on the models. This is because Postgres maintains a cache on each instance its running on. Though you may have the same dataset, Postgres maintains frequently accessed or queried data in the cache giving you better performance. For more on this you can read earlier posts on <a href="http://www.craigkerstiens.com/2012/11/30/sharding-your-database/">PostgreSQL Performance</a>.</em></p>

<h3>Setting it up with Rails</h3>

<p>With a follower database created you can begin adding support for this to your application. The first thing is to add the gem to your Gemfile:</p>

<pre><code>gem 'ar-octopus', :require =&gt; "octopus"
</code></pre>

<p>Then of course to install it with <code>bundle install</code>. Now we can actually begin to add the code needed to have specific models access the follower.</p>

<pre><code>octopus:
shards:
  shard_sqlite:
  adapter: sqlite3
  database: db/db_one.sqlite3
  pool: 5
  timeout: 5000

  shard_pgsql:
    adapter: postgresql
    username: postgres
    password:
    database: db_two
    encoding: unicode
</code></pre>

<p>a</p>

<pre><code>class Project &lt; ActiveRecord::Base
  octopus_establish_connection(:adapter =&gt; "sqlite3", :database =&gt; "db_one")
end
</code></pre>
]]></content>
  </entry>
  
</feed>
